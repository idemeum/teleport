AWSTemplateFormatVersion: '2010-09-09'
Description: Remote Access
Parameters:

  TenantId:
    Description: Tenant ID (UUID)
    Type: String

  TenantName:
    Description: Tenant Name (lower case)
    Type: String

  IdemeumDomain:
    Description: Idemeum domain name
    Type: String
    Default: idemeum.com
    AllowedValues:
    - idemeumlab.com
    - idemeum.com
    - idemeum.in

  DeploymentType:
    Description: Remote Access deployment configuration type
    ConstraintDescription: must be a valid EC2 instance type.
    Type: String
    Default: LA-Starter
    AllowedValues:
    - LA-Starter
    - LA-MICRO
    - LA-SMALL
    - LA-MEDIUM
    - HA-MICRO
    - HA-SMALL
    - HA-MEDIUM

  RemoteAccessVersion:
    Description: Remote Access version
    Type: String
    Default: 1.0.0.1918067ae
    AllowedValues:
    - 1.0.0.1918067ae
    - 1.0.0.b50a1788d

  Mode:
    Description: Allows deactivation of stack that would shut down compute and load balancers
    Type: String
    Default: Active
    AllowedValues:
    - Active
    - Inactive

  EventsRetentionDays:
    Description: Number of days to keep audit events
    Type: Number
    Default: 365

Mappings:

  RegionId:
    ap-south-1: {ID: APSOUTH1}
    us-west-2: {ID: USAWEST2}

  VersionConfig:
    1.0.0.1918067ae:
      GitHash: 1918067ae
      APSOUTH1: ami-078bcb3d90eec1664
      USAWEST2: ami-03e2f8b9495595bea
    1.0.0.b50a1788d:
      GitHash: b50a1788d
      APSOUTH1: ami-0945be6373281808d
      USAWEST2: ami-0e444164f0335fcd7

  DeploymentTypeConfig:
    LA-Starter:
      AuthType: t3a.nano
      ProxyType: t3a.nano
      MaxConns: 100
      MaxUsers: 50
    LA-MICRO:
      AuthType: t3a.micro
      ProxyType: t3a.micro
      MaxConns: 250
      MaxUsers: 150
    LA-SMALL:
      AuthType: t3a.small
      ProxyType: t3a.small
      MaxConns: 500
      MaxUsers: 300
    LA-MEDIUM:
      AuthType: t3a.medium
      ProxyType: t3a.medium
      MaxConns: 1000
      MaxUsers: 800
    HA-MICRO:
      AuthType: t3a.micro
      ProxyType: t3a.micro
      MaxConns: 400
      MaxUsers: 250
    HA-SMALL:
      AuthType: t3a.small
      ProxyType: t3a.small
      MaxConns: 1000
      MaxUsers: 750
    HA-MEDIUM:
      AuthType: t3a.medium
      ProxyType: t3a.medium
      MaxConns: 2500
      MaxUsers: 1500


Conditions:
  HighAvailablity: !And [!Equals [ !Select [ 0, !Split [ "-", !Ref DeploymentType ]], "HA" ], !Equals [!Ref Mode, 'Active'] ]
  LowAvailablity:  !And [!Equals [ !Select [ 0, !Split [ "-", !Ref DeploymentType ]], "LA" ], !Equals [!Ref Mode, 'Active'] ]
  ModeActive: !Equals [!Ref Mode, 'Active']

Resources:
# Auth server setup
  AuthSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: ModeActive
    Properties:
      GroupName: !Join [" ", ["Remote Access ", !Ref TenantName, " AuthSecurityGroup"]]
      GroupDescription: Remote Access - Allow proxy and auth server access
      VpcId: '{{resolve:ssm:/Services/VPC/Id}}'
      SecurityGroupIngress:
        - IpProtocol: tcp
          Description: Everyone is allowed to use auth service API.
          FromPort: 3025
          ToPort: 3025
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: "-1"
          Description: Egress is allowed anywhere
          FromPort: 0
          ToPort: 0
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " AuthSecurityGroup"]]
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName

  AuthEc2Instance:
    Type: AWS::EC2::Instance
    Condition: LowAvailablity
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT10M
    Properties:
      IamInstanceProfile: !Ref AuthInstanceProfile
      ImageId: !FindInMap [VersionConfig, !Ref RemoteAccessVersion, !FindInMap [RegionId, !Ref 'AWS::Region', ID]]
      InstanceType: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, AuthType]
      SecurityGroupIds:
        - Ref: AuthSecurityGroup
      SubnetId: '{{resolve:ssm:/Services/VPC/PrivateSubnetAZ1}}'
      UserData:
        Fn::Base64:
          # Fn:Sub accepts two parameters as a list, the first one is the template
          # the second parameter is a dictionary with template-local variables
          Fn::Sub:
          - |
            #!/bin/bash -xe

            # Indicate that this ami is auth for all systemd units
            echo "auth" >> /etc/teleport.d/role.auth

            # Set some instance specific environment variables configurations for systemd configuration file
            cat >> /etc/teleport.d/conf <<EOF
            EC2_REGION=${AWS::Region}
            TELEPORT_AUTH_SERVER_LB=DEFAULT
            TELEPORT_CLUSTER_NAME=${DomainName}
            TELEPORT_DOMAIN_ADMIN_EMAIL=${DomainAdminEmail}
            TELEPORT_DOMAIN_NAME=${DomainName}
            TELEPORT_DYNAMO_TABLE_NAME=${LocalMainTableName}
            TELEPORT_DYNAMO_EVENTS_TABLE_NAME=${LocalEventsTableName}
            TELEPORT_LOCKS_TABLE_NAME=${LocalLocksTableName}
            TELEPORT_S3_BUCKET=${LocalBucketName}
            TELEPORT_ROLE=auth
            USE_LETSENCRYPT=true
            IDEMEUM_TENANT=${Tenant}
            AUDIT_RETENTION_DAYS=${EventsRetentionDays}
            EOF

            # Generate config and start proxy service
            /usr/local/bin/teleport-generate-config
            systemctl enable teleport-ssm-publish-tokens.service teleport-ssm-publish-tokens.timer teleport-get-cert.service teleport-get-cert.timer teleport-renew-cert.service teleport-renew-cert.timer
            systemctl start --no-block teleport-auth teleport-ssm-publish-tokens.timer teleport-get-cert.timer teleport-renew-cert.timer

            # Write out healthcheck script
            cat >> /usr/local/bin/teleport-cfn-signal-done <<EOF
            #!/bin/bash
            for i in {1..10}; do systemctl status teleport-auth && break || sleep 10; done
            systemctl status teleport-auth
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource AuthEc2Instance --region ${AWS::Region}
            EOF

            # Make healthcheck script executable
            chmod +x /usr/local/bin/teleport-cfn-signal-done

            # Write out healthcheck systemd unit file
            cat >> /etc/systemd/system/cfn-signal-done.service <<EOF
            [Unit]
            Description=CloudFormation status signaller
            After=network.target

            [Service]
            User=root
            Group=adm
            Type=oneshot
            ExecStart=/usr/local/bin/teleport-cfn-signal-done
            EOF

            # Make systemd healthcheck unit run
            systemctl daemon-reload
            systemctl start --no-block cfn-signal-done.service
          - {
            DomainName: !Join [".", [!Ref TenantName, "remote", !Ref IdemeumDomain]],
            DomainAdminEmail: !Join ["@", ['support', !Ref IdemeumDomain]],
            Tenant: !Join [".", [!Ref TenantName, !Ref IdemeumDomain]],
            LocalMainTableName: !Select [1, !Split ["/", !GetAtt MainTable.Arn]],
            LocalLocksTableName: !Select [1, !Split ["/", !GetAtt LocksTable.Arn]],
            LocalEventsTableName: !Select [1, !Split ["/", !GetAtt EventsTable.Arn]],
            LocalBucketName: !Select [1, !Split [":::", !GetAtt Bucket.Arn]]
            }
      Tags:
        - Key: Name
          Value: !Join ['-', ["remote-access", !Ref TenantName, "auth"]]
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " - AuthEc2Instance"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com
        - Key: VantaNoAlert
          Value: 'Need to have this with public port available so the reverse proxy will work. Also no alarm will be created for CPU'

  AuthLaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Condition: HighAvailablity
    Properties:
      # This line finds appropriate image ID based on the arch, region and instance type using FindInMap function
      ImageId: !FindInMap [VersionConfig, !Ref RemoteAccessVersion, !FindInMap [RegionId, !Ref 'AWS::Region', ID]]
      UserData:
        Fn::Base64:
          # Fn:Sub accepts two parameters as a list, the first one is the template
          # the second parameter is a dictionary with template-local variables
          Fn::Sub:
          - |
            #!/bin/bash -xe

            # Indicate that this ami is auth for all systemd units
            echo "auth" >> /etc/teleport.d/role.auth

            # Set some instance specific environment variables configurations for systemd configuration file
            cat >> /etc/teleport.d/conf <<EOF
            EC2_REGION=${AWS::Region}
            TELEPORT_AUTH_SERVER_LB=${LocalAuthServerLB}
            TELEPORT_CLUSTER_NAME=${DomainName}
            TELEPORT_DOMAIN_ADMIN_EMAIL=${DomainAdminEmail}
            TELEPORT_DOMAIN_NAME=${DomainName}
            TELEPORT_DYNAMO_TABLE_NAME=${LocalMainTableName}
            TELEPORT_DYNAMO_EVENTS_TABLE_NAME=${LocalEventsTableName}
            TELEPORT_LOCKS_TABLE_NAME=${LocalLocksTableName}
            TELEPORT_S3_BUCKET=${LocalBucketName}
            TELEPORT_ROLE=auth
            USE_LETSENCRYPT=true
            IDEMEUM_TENANT=${Tenant}
            AUDIT_RETENTION_DAYS=${EventsRetentionDays}
            EOF

            # Generate config and start proxy service
            /usr/local/bin/teleport-generate-config
            systemctl enable teleport-ssm-publish-tokens.service teleport-ssm-publish-tokens.timer teleport-get-cert.service teleport-get-cert.timer teleport-renew-cert.service teleport-renew-cert.timer
            systemctl start --no-block teleport-auth teleport-ssm-publish-tokens.timer teleport-get-cert.timer teleport-renew-cert.timer

            # Write out healthcheck script
            cat >> /usr/local/bin/teleport-cfn-signal-done <<EOF
            #!/bin/bash
            for i in {1..10}; do systemctl status teleport-auth && break || sleep 10; done
            systemctl status teleport-auth
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource AuthASG --region ${AWS::Region}
            EOF

            # Make healthcheck script executable
            chmod +x /usr/local/bin/teleport-cfn-signal-done

            # Write out healthcheck systemd unit file
            cat >> /etc/systemd/system/cfn-signal-done.service <<EOF
            [Unit]
            Description=CloudFormation status signaller
            After=network.target

            [Service]
            User=root
            Group=adm
            Type=oneshot
            ExecStart=/usr/local/bin/teleport-cfn-signal-done
            EOF

            # Make systemd healthcheck unit run
            systemctl daemon-reload
            systemctl start --no-block cfn-signal-done.service
          - {
            DomainName: !Join [".", [!Ref TenantName, "remote", !Ref IdemeumDomain]],
            DomainAdminEmail: !Join ["@", ['support', !Ref IdemeumDomain]],
            Tenant: !Join [".", [!Ref TenantName, !Ref IdemeumDomain]],
            LocalAuthServerLB: !GetAtt AuthLB.DNSName,
            LocalMainTableName: !Select [1, !Split ["/", !GetAtt MainTable.Arn]],
            LocalLocksTableName: !Select [1, !Split ["/", !GetAtt LocksTable.Arn]],
            LocalEventsTableName: !Select [1, !Split ["/", !GetAtt EventsTable.Arn]],
            LocalBucketName: !Select [1, !Split [":::", !GetAtt Bucket.Arn]]
            }
      SecurityGroups:
        - Ref: AuthSecurityGroup
      InstanceType: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, AuthType]
      IamInstanceProfile: {Ref: AuthInstanceProfile}
      # Proxies have to have public IP address in order
      # to be reachable from the internet according to this
      # article: https://aws.amazon.com/premiumsupport/knowledge-center/public-load-balancer-private-ec2/
      AssociatePublicIpAddress: false

  AuthLB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Condition: HighAvailablity
    Properties:
      Scheme: internal
      Type: network
      Subnets:
        - '{{resolve:ssm:/Services/VPC/PrivateSubnetAZ1}}'
        - '{{resolve:ssm:/Services/VPC/PrivateSubnetAZ2}}'
      Tags:
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " AuthLB"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com

  AuthLBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Condition: HighAvailablity
    Properties:
      DefaultActions:
      - Type: forward
        TargetGroupArn:
          Ref: AuthTargetGroup
      LoadBalancerArn:
        Ref: AuthLB
      Port: 3025
      Protocol: TCP

  AuthTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Condition: HighAvailablity
    Properties:
      HealthCheckIntervalSeconds: 30
      HealthCheckProtocol: TCP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 4
      UnhealthyThresholdCount: 4
      Port: 3025
      Protocol: TCP
      VpcId: '{{resolve:ssm:/Services/VPC/Id}}'

  AuthASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    Condition: HighAvailablity
    CreationPolicy:
      ResourceSignal:
        Count: 2
        Timeout: PT10M
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MaxBatchSize: 1
        MinInstancesInService: 0
        MinSuccessfulInstancesPercent: 100
        PauseTime: PT5M
        WaitOnResourceSignals: true
    Properties:
      # Use IDs of the subnets created in two AZs
      # to let AWS know we want instances to be placed
      # in those subnets.
      VPCZoneIdentifier:
        - '{{resolve:ssm:/Services/VPC/PrivateSubnetAZ1}}'
        - '{{resolve:ssm:/Services/VPC/PrivateSubnetAZ2}}'
      LaunchConfigurationName: {Ref: AuthLaunchConfig}
      MinSize: "2"
      MaxSize: "2"
      TargetGroupARNs:
        - {Ref: AuthTargetGroup}
      Tags:
        - Key: Name
          Value: !Join ['-', ["remote-access", !Ref TenantName, "auth"]]
          PropagateAtLaunch: true
        - Key: TenantId
          Value: !Ref TenantId
          PropagateAtLaunch: true
        - Key: TenantName
          Value: !Ref TenantName
          PropagateAtLaunch: true
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " - AuthASG"]]
          PropagateAtLaunch: true
        - Key: VantaOwner
          Value: goprean@idemeum.com
          PropagateAtLaunch: true

  #
  # Proxy Setup
  #
  ProxySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: ModeActive
    Properties:
      GroupName: !Join [" ", ["Remote Access ", !Ref TenantName, " ProxySecurityGroup"]]
      GroupDescription: Remote Access - Allow proxy and auth server access
      VpcId: '{{resolve:ssm:/Services/VPC/Id}}'
      SecurityGroupIngress:
        - IpProtocol: tcp
          Description: Port for SSH clients
          FromPort: 3023
          ToPort: 3023
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          Description: Port for HTTPS connections
          FromPort: !If [HighAvailablity, '3080', '443']
          ToPort: !If [HighAvailablity, '3080', '443']
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: "-1"
          Description: Egress is allowed anywhere
          FromPort: 0
          ToPort: 0
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: Name
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " ProxySecurityGroup"]]
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName

  ProxyLB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Condition: HighAvailablity
    Properties:
      Type: network
      LoadBalancerAttributes:
        - Key: load_balancing.cross_zone.enabled
          Value: 'true'
      Subnets:
        - '{{resolve:ssm:/Services/VPC/PublicSubnetAZ1}}'
        - '{{resolve:ssm:/Services/VPC/PublicSubnetAZ2}}'
      Tags:
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " - ProxyLB"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com

  ProxyDNS:
    Type: AWS::Route53::RecordSetGroup
    Condition: ModeActive
    Properties:
      HostedZoneId: '{{resolve:ssm:/Services/Route53/RemoteAccessHostedZoneID}}'
      Comment: Zone Alias for DNS
      RecordSets:
      - Name: !Join [".", [!Ref TenantName, "remote", !Ref IdemeumDomain]]
        Type: !If [HighAvailablity, 'CNAME', 'A']
        ResourceRecords:
        - !If [HighAvailablity, !GetAtt ProxyLB.DNSName, !GetAtt ProxyEc2Instance.PublicIp]
        TTL: 60
      - Name: !Join [".", ["*", !Ref TenantName, "remote", !Ref IdemeumDomain]]
        Type: !If [HighAvailablity, 'CNAME', 'A']
        ResourceRecords:
        - !If [HighAvailablity, !GetAtt ProxyLB.DNSName, !GetAtt ProxyEc2Instance.PublicIp]
        TTL: 60

  ProxyLBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Condition: HighAvailablity
    Properties:
      DefaultActions:
      - Type: forward
        TargetGroupArn:
          Ref: ProxyWebTargetGroup
      LoadBalancerArn:
        Ref: ProxyLB
      Port: 443
      Protocol: TCP

  ProxyWebTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Condition: HighAvailablity
    Properties:
      HealthCheckIntervalSeconds: 30
      HealthCheckProtocol: TCP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 4
      UnhealthyThresholdCount: 4
      Port: 3080
      Protocol: TCP
      VpcId: '{{resolve:ssm:/Services/VPC/Id}}'


  ProxyEc2Instance:
    Type: AWS::EC2::Instance
    Condition: LowAvailablity
    CreationPolicy:
      ResourceSignal:
        Count: 1
        Timeout: PT30M
    Properties:
      IamInstanceProfile: !Ref ProxyInstanceProfile
      ImageId: !FindInMap [VersionConfig, !Ref RemoteAccessVersion, !FindInMap [RegionId, !Ref 'AWS::Region', ID]]
      InstanceType: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, ProxyType]
      NetworkInterfaces:
        - AssociatePublicIpAddress: "true"
          DeviceIndex: "0"
          GroupSet:
            - Ref: ProxySecurityGroup
          SubnetId: '{{resolve:ssm:/Services/VPC/PublicSubnetAZ1}}'
      UserData:
        Fn::Base64:
          # Fn:Sub accepts two parameters as a list, the first one is the template
          # the second parameter is a dictionary with template-local variables
          Fn::Sub:
          - |
            #!/bin/bash -xe

            # Indicate that this ami is proxy for all systemd units
            echo "proxy" >> /etc/teleport.d/role.proxy

            # Set some instance specific environment variables configurations for systemd configuration file
            cat >> /etc/teleport.d/conf <<EOF
            EC2_REGION=${AWS::Region}
            TELEPORT_AUTH_SERVER_LB=${LocalAuthServerAddress}
            TELEPORT_CLUSTER_NAME=${DomainName}
            TELEPORT_DOMAIN_NAME=${DomainName}
            TELEPORT_PROXY_SERVER_LB=DEFAULT
            TELEPORT_ROLE=proxy
            TELEPORT_S3_BUCKET=${LocalBucketName}
            USE_LETSENCRYPT=true
            IDEMEUM_TENANT=${Tenant}
            MAX_CONNECTIONS=${MaxConnections}
            MAX_USERS=${MaxUsers}
            TELEPORT_INTERNAL_PORT=443
            EOF

            # Generate config and start proxy service
            /usr/local/bin/teleport-generate-config
            systemctl enable teleport-proxy.service teleport-check-cert.service teleport-check-cert.timer
            systemctl start --no-block teleport-proxy.service teleport-check-cert.timer

            # Write out healthcheck script
            cat >> /usr/local/bin/teleport-cfn-signal-done <<EOF
            #!/bin/bash
            for i in {1..40}; do systemctl status teleport-proxy && break || sleep 30; done
            systemctl status teleport-proxy
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ProxyEc2Instance --region ${AWS::Region}
            EOF

            # Make healthcheck script executable
            chmod +x /usr/local/bin/teleport-cfn-signal-done

            # Write out healthcheck systemd unit file
            cat >> /etc/systemd/system/cfn-signal-done.service <<EOF
            [Unit]
            Description=CloudFormation status signaller
            After=network.target

            [Service]
            User=root
            Group=adm
            Type=oneshot
            ExecStart=/usr/local/bin/teleport-cfn-signal-done
            EOF

            # Make systemd healthcheck unit run
            systemctl daemon-reload
            systemctl start --no-block cfn-signal-done.service
          - {
            DomainName: !Join [".", [!Ref TenantName, "remote", !Ref IdemeumDomain]],
            Tenant: !Join [".", [!Ref TenantName, !Ref IdemeumDomain]],
            LocalAuthServerAddress: !GetAtt  AuthEc2Instance.PrivateIp,
            LocalBucketName: !Select [1, !Split [":::", !GetAtt Bucket.Arn]],
            MaxConnections: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, MaxConns],
            MaxUsers: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, MaxUsers]
            }
      Tags:
        - Key: Name
          Value: !Join ['-', ["remote-access", !Ref TenantName, "proxy"]]
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " - ProxyEc2Instance"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com
        - Key: VantaNoAlert
          Value: 'Need to have this with public port available so the reverse proxy will work. Also no alarm will be created for CPU'

  ProxyLaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Condition: HighAvailablity
    Properties:
      # This line finds appropriate image ID based on the arch, region and instance type using FindInMap function
      ImageId: !FindInMap [VersionConfig, !Ref RemoteAccessVersion, !FindInMap [RegionId, !Ref 'AWS::Region', ID]]
      UserData:
        Fn::Base64:
          # Fn:Sub accepts two parameters as a list, the first one is the template
          # the second parameter is a dictionary with template-local variables
          Fn::Sub:
          - |
            #!/bin/bash -xe

            # Indicate that this ami is proxy for all systemd units
            echo "proxy" >> /etc/teleport.d/role.proxy

            # Set some instance specific environment variables configurations for systemd configuration file
            cat >> /etc/teleport.d/conf <<EOF
            EC2_REGION=${AWS::Region}
            TELEPORT_AUTH_SERVER_LB=${LocalAuthServerLB}
            TELEPORT_CLUSTER_NAME=${DomainName}
            TELEPORT_DOMAIN_NAME=${DomainName}
            TELEPORT_PROXY_SERVER_LB=${LocalProxyServerLB}
            TELEPORT_ROLE=proxy
            TELEPORT_S3_BUCKET=${LocalBucketName}
            USE_LETSENCRYPT=true
            IDEMEUM_TENANT=${Tenant}
            MAX_CONNECTIONS=${MaxConnections}
            MAX_USERS=${MaxUsers}
            EOF

            # Generate config and start proxy service
            /usr/local/bin/teleport-generate-config
            systemctl enable teleport-proxy.service teleport-check-cert.service teleport-check-cert.timer
            systemctl start --no-block teleport-proxy.service teleport-check-cert.timer

            # Write out healthcheck script
            cat >> /usr/local/bin/teleport-cfn-signal-done <<EOF
            #!/bin/bash
            for i in {1..40}; do systemctl status teleport-proxy && break || sleep 30; done
            systemctl status teleport-proxy
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource ProxyASG --region ${AWS::Region}
            EOF

            # Make healthcheck script executable
            chmod +x /usr/local/bin/teleport-cfn-signal-done

            # Write out healthcheck systemd unit file
            cat >> /etc/systemd/system/cfn-signal-done.service <<EOF
            [Unit]
            Description=CloudFormation status signaller
            After=network.target

            [Service]
            User=root
            Group=adm
            Type=oneshot
            ExecStart=/usr/local/bin/teleport-cfn-signal-done
            EOF

            # Make systemd healthcheck unit run
            systemctl daemon-reload
            systemctl start --no-block cfn-signal-done.service
          - {
            DomainName: !Join [".", [!Ref TenantName, "remote", !Ref IdemeumDomain]],
            Tenant: !Join [".", [!Ref TenantName, !Ref IdemeumDomain]],
            LocalAuthServerLB: !GetAtt AuthLB.DNSName,
            LocalProxyServerLB: !GetAtt ProxyLB.DNSName,
            LocalBucketName: !Select [1, !Split [":::", !GetAtt Bucket.Arn]],
            MaxConnections: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, MaxConns],
            MaxUsers: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, MaxUsers]
            }
      SecurityGroups:
        - Ref: ProxySecurityGroup
      InstanceType: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, ProxyType]
      # Proxies have to have public IP address in order
      # to be reachable from the internet according to this
      # article: https://aws.amazon.com/premiumsupport/knowledge-center/public-load-balancer-private-ec2/
      AssociatePublicIpAddress: true
      # IamInstance profile is an instance profile of the proxy
      IamInstanceProfile: {Ref: ProxyInstanceProfile}

  ProxyASG:
    Type: AWS::AutoScaling::AutoScalingGroup
    Condition: HighAvailablity
    CreationPolicy:
      ResourceSignal:
        Count: 2
        Timeout: PT30M
    UpdatePolicy:
      AutoScalingRollingUpdate:
        MaxBatchSize: 1
        MinInstancesInService: 1
        MinSuccessfulInstancesPercent: 100
        PauseTime: PT10M
        WaitOnResourceSignals: true
    Properties:
      # Use IDs of the subnets created in two AZs
      # to let AWS know we want instances to be placed
      # in those subnets.
      VPCZoneIdentifier:
        - '{{resolve:ssm:/Services/VPC/PublicSubnetAZ1}}'
        - '{{resolve:ssm:/Services/VPC/PublicSubnetAZ2}}'
      LaunchConfigurationName: {Ref: ProxyLaunchConfig}
      MinSize: "2"
      MaxSize: "2"
      TargetGroupARNs:
        - {Ref: ProxyWebTargetGroup}
      Tags:
        - Key: Name
          Value: !Join ['-', ["remote-access", !Ref TenantName, "proxy"]]
          PropagateAtLaunch: true
        - Key: TenantId
          Value: !Ref TenantId
          PropagateAtLaunch: true
        - Key: TenantName
          Value: !Ref TenantName
          PropagateAtLaunch: true
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " - ProxyASG"]]
          PropagateAtLaunch: true
        - Key: VantaOwner
          Value: goprean@idemeum.com
          PropagateAtLaunch: true

  AuthRole:
    Type: AWS::IAM::Role
    Condition: ModeActive
    Properties:
      RoleName: !Join ['-', [ 'RemoteAccess', !Ref TenantName, !Ref AWS::Region, 'AuthRole']]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - "ec2.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore

  # Allows auth server to publish join tokens
  # to SSM parameter store
  AuthPolicies:
    Type: AWS::IAM::Policy
    Condition: ModeActive
    Properties:
      PolicyName: !Join ['-', [ 'RemoteAccess', !Ref TenantName, !Ref AWS::Region, 'AuthRole', 'ssm']]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          # Allow auth server to update SSM instance status
          -
            Effect: "Allow"
            Resource: !Join ["", ["arn:aws:ssm:", !Ref "AWS::Region", ":", !Ref "AWS::AccountId", ":instance/*" ]]
            Action:
            - "ssm:UpdateInstanceInformation"
          # Allow auth server to publish join tokens to SSM parameter store
          -
            Effect: "Allow"
            Resource: !Join ["", ["arn:aws:ssm:", !Ref "AWS::Region", ":", !Ref "AWS::AccountId", ":parameter/teleport/", !Ref TenantName, '.remote.', !Ref IdemeumDomain, "/*"]]
            Action:
            - "ssm:DescribeParameters"
            - "ssm:GetParameters"
            - "ssm:GetParametersByPath"
            - "ssm:GetParameter"
            - "ssm:PutParameter"
            - "ssm:DeleteParameter"
          # Allow auth server to control main dynamo db table
          -
            Effect: "Allow"
            Resource: !GetAtt MainTable.Arn
            Action:
            - "dynamodb:BatchGet*"
            - "dynamodb:DescribeStream"
            - "dynamodb:DescribeTable"
            - "dynamodb:Get*"
            - "dynamodb:Query"
            - "dynamodb:Scan"
            - "dynamodb:BatchWrite*"
            - "dynamodb:CreateTable"
            - "dynamodb:Delete*"
            - "dynamodb:Update*"
            - "dynamodb:PutItem"
            - "dynamodb:List*"
            - "dynamodb:DescribeReservedCapacity*"
            - "dynamodb:DescribeLimits"
            - "dynamodb:DescribeTimeToLive"

          # Allow auth server to use streams on main DynamoDB table
          -
            Effect: "Allow"
            Resource: !Join ["", [!GetAtt MainTable.Arn, "/stream/*"]]
            Action:
            - "dynamodb:DescribeStream"
            - "dynamodb:ListStream"
            - "dynamodb:GetRecords"
            - "dynamodb:GetShardIterator"

          # Allow auth server to control audit dynamo db table
          # and it's secondary indexes
          -
            Effect: "Allow"
            Resource: !GetAtt EventsTable.Arn
            Action:
            - "dynamodb:BatchGet*"
            - "dynamodb:DescribeStream"
            - "dynamodb:DescribeTable"
            - "dynamodb:Get*"
            - "dynamodb:Query"
            - "dynamodb:Scan"
            - "dynamodb:BatchWrite*"
            - "dynamodb:CreateTable"
            - "dynamodb:Delete*"
            - "dynamodb:Update*"
            - "dynamodb:PutItem"
            - "dynamodb:List*"
            - "dynamodb:DescribeReservedCapacity*"
            - "dynamodb:DescribeLimits"
            - "dynamodb:DescribeTimeToLive"

          -
            Effect: "Allow"
            Resource: !Join ["", [!GetAtt EventsTable.Arn, "/index/*"]]
            Action:
            - "dynamodb:Query"
            - "dynamodb:Scan"

          # Allow auth server to control locks dynamo db table
          -
            Effect: "Allow"
            Resource: !GetAtt LocksTable.Arn
            Action:
            - "dynamodb:BatchGet*"
            - "dynamodb:DescribeStream"
            - "dynamodb:DescribeTable"
            - "dynamodb:Get*"
            - "dynamodb:Query"
            - "dynamodb:Scan"
            - "dynamodb:BatchWrite*"
            - "dynamodb:CreateTable"
            - "dynamodb:Delete*"
            - "dynamodb:Update*"
            - "dynamodb:PutItem"
            - "dynamodb:List*"
            - "dynamodb:DescribeReservedCapacity*"
            - "dynamodb:DescribeLimits"
            - "dynamodb:DescribeTimeToLive"

          # Auth server is allowed to send sqs messages to appmanagement
          -
            Effect: "Allow"
            Resource: !Join [":", ["arn:aws:sqs", !Ref "AWS::Region", !Ref "AWS::AccountId", "remote-access-audit-event-notification-queue" ]]
            Action:
            - "sqs:SendMessage"
            - "sqs:GetQueueAttributes"
            - "sqs:GetQueueUrl"
          -
            Effect: "Allow"
            Resource: !Join [":", ["arn:aws:sqs", !Ref "AWS::Region", !Ref "AWS::AccountId", "remote-access-resource-change-notification-queue" ]]
            Action:
            - "sqs:SendMessage"
            - "sqs:GetQueueAttributes"
            - "sqs:GetQueueUrl"
          -
            Effect: "Allow"
            Resource: !Join [":", ["arn:aws:sqs", !Ref "AWS::Region", !Ref "AWS::AccountId", "remote-access-sync-queue" ]]
            Action:
            - "sqs:SendMessage"
            - "sqs:GetQueueAttributes"
            - "sqs:GetQueueUrl"
          # Auth server is allowed to read and write from the bucket
          -
            Effect: "Allow"
            Resource: !GetAtt Bucket.Arn
            Action:
            - "s3:ListBucket"
            - "s3:ListBucketVersions"
            - "s3:ListBucketMultipartUploads"
            - "s3:AbortMultipartUpload"

          -
            Effect: "Allow"
            Resource: !Join ["/", [!GetAtt Bucket.Arn, "*"]]
            Action:
            - "s3:GetObject"
            - "s3:PutObject"
            - "s3:GetObjectVersion"

          # Allow to list hosted zone changes
          -
            Effect: "Allow"
            Resource: "*"
            Action:
            - "route53:ListHostedZones"
            - "route53:GetChange"

          # Allow auth server to modify record sets (for DNS-01 letsencrypt challenge)
          # DNS-01 is the most reliable challenge up to date, that's why we are using it
          -
            Effect: "Allow"
            Resource: !Join ["/", ["arn:aws:route53:::hostedzone", '{{resolve:ssm:/Services/Route53/RemoteAccessHostedZoneID}}']]
            Action:
            - "route53:ChangeResourceRecordSets"
      Roles:
      - {Ref: AuthRole}

  AuthInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Condition: ModeActive
    Properties:
      Roles:
      - {Ref: AuthRole}

  ProxyRole:
    Type: AWS::IAM::Role
    Condition: ModeActive
    Properties:
      RoleName: !Join ['-', [ 'RemoteAccess', !Ref TenantName, !Ref AWS::Region, 'ProxyRole']]
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          -
            Effect: "Allow"
            Principal:
              Service:
                - "ec2.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore

  # Allows proxies to read tokens from SSM parameter store
  # And read certs from encrypted S3 bucket
  ProxyPolicies:
    Type: AWS::IAM::Policy
    Condition: ModeActive
    Properties:
      PolicyName: !Join ['-', [ 'RemoteAccess', !Ref TenantName, !Ref AWS::Region, 'ProxyRole', 'ssm']]
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          # Allow proxy to update SSM instance status
          - Effect: "Allow"
            Resource: !Join ["", ["arn:aws:ssm:", !Ref "AWS::Region", ":", !Ref "AWS::AccountId", ":instance/*" ]]
            Action:
            - "ssm:UpdateInstanceInformation"
          # Allow proxy to read tokens and CA from SSM parameter store
          - Effect: "Allow"
            Resource: !Join ["", ["arn:aws:ssm:", !Ref "AWS::Region", ":", !Ref "AWS::AccountId", ":parameter/teleport/", !Ref TenantName, '.remote.', !Ref IdemeumDomain, "/tokens/proxy"]]
            Action:
            - "ssm:GetParameters"
            - "ssm:GetParametersByPath"
            - "ssm:GetParameter"

          # Allow proxy to read tokens and CA from SSM parameter store
          -
            Effect: "Allow"
            Resource: !Join ["", ["arn:aws:ssm:", !Ref "AWS::Region", ":", !Ref "AWS::AccountId", ":parameter/teleport/", !Ref TenantName, '.remote.', !Ref IdemeumDomain, "/ca-pin-hash"]]
            Action:
            - "ssm:GetParameters"
            - "ssm:GetParametersByPath"
            - "ssm:GetParameter"

          # Allow auth server to read from S3 bucket
          -
            Effect: "Allow"
            Resource: !GetAtt Bucket.Arn
            Action:
            - "s3:ListBucket"
            - "s3:ListBucketVersions"
            - "s3:ListBucketMultipartUploads"
            - "s3:AbortMultipartUpload"

          -
            Effect: "Allow"
            Resource: !Join ["/", [!GetAtt Bucket.Arn, "*"]]
            Action:
            - "s3:GetObject"
            - "s3:GetObjectVersion"

      Roles:
      - {Ref: ProxyRole}

  ProxyInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Condition: ModeActive
    Properties:
      Roles:
      - {Ref: ProxyRole}


  # MainTable is a main dynamodb table
  # where teleport stores all relevant state
  MainTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Retain
    Properties:
      TableName: !Join ["_", [RemoteAccessMain, !Ref TenantName]]
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
      AttributeDefinitions:
        - AttributeName: HashKey
          AttributeType: S
        - AttributeName: FullPath
          AttributeType: S
      KeySchema:
        - AttributeName: HashKey
          KeyType: HASH
        - AttributeName: FullPath
          KeyType: RANGE
      TimeToLiveSpecification:
        AttributeName: Expires
        Enabled: true
      StreamSpecification:
        StreamViewType: NEW_IMAGE
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " -  Main Table"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com
        - Key: VantaNoAlert
          Value: 'Will not create read/write monitoring alarms for this table.'


  # LocksTable is a dynamodb table that is
  # used as a distributed lock between auth servers
  # trying to renew and manage letsencrypt certificate
  LocksTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    Properties:
      TableName: !Join ["_", [RemoteAccessLocks, !Ref TenantName]]
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
      AttributeDefinitions:
        - AttributeName: Lock
          AttributeType: S
      KeySchema:
        - AttributeName: Lock
          KeyType: HASH
      TimeToLiveSpecification:
        AttributeName: Expires
        Enabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " -  Locks Table"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com
        - Key: VantaNoAlert
          Value: 'Will not create read/write monitoring alarms for this table.'

  EventsTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Retain
    Properties:
      TableName: !Join ["_", [RemoteAccessEvents, !Ref TenantName]]
      BillingMode: PAY_PER_REQUEST
      SSESpecification:
        SSEEnabled: true
      AttributeDefinitions:
        - AttributeName: SessionID
          AttributeType: S
        - AttributeName: EventIndex
          AttributeType: N
        - AttributeName: CreatedAtDate
          AttributeType: S
        - AttributeName: CreatedAt
          AttributeType: N
      KeySchema:
        - AttributeName: SessionID
          KeyType: HASH
        - AttributeName: EventIndex
          KeyType: RANGE
      TimeToLiveSpecification:
        AttributeName: Expires
        Enabled: true
      GlobalSecondaryIndexes:
      - IndexName: timesearchV2
        KeySchema:
        - AttributeName: CreatedAtDate
          KeyType: HASH
        - AttributeName: CreatedAt
          KeyType: RANGE
        Projection:
          ProjectionType: ALL
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " - Events Table"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com
        - Key: VantaNoAlert
          Value: 'Will not create read/write monitoring alarms for this table.'          
  # Bucket is used to publish letsencrypt certs
  # and store recorded SSH sessions
  Bucket:
    Type: AWS::S3::Bucket
    # Cloudformation can't delete non-empty bucket
    DeletionPolicy: Retain
    Properties:
      BucketName: !Join ['-', [ 'remote-access', !Ref TenantName, !Ref AWS::AccountId, !Ref AWS::Region]]
      VersioningConfiguration: {Status: Enabled}
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault: {SSEAlgorithm: AES256}
      Tags:
        - Key: TenantId
          Value: !Ref TenantId
        - Key: TenantName
          Value: !Ref TenantName
        - Key: VantaDescription
          Value: !Join [" ", ["Remote Access ", !Ref TenantName, " -  S3 bucket for certs and recordings"]]
        - Key: VantaOwner
          Value: goprean@idemeum.com
Outputs:
  DeploymentType:
    Value: !Ref DeploymentType
    Export:
      Name: !Join ["-", ["RA", !Ref TenantName, "DeploymentType"]]
  RemoteAccessVersion:
    Value: !Ref RemoteAccessVersion
    Export:
      Name: !Join ["-", ["RA", !Ref TenantName, "RemoteAccessVersion"]]
  GitHash:
    Value: !FindInMap [VersionConfig, !Ref RemoteAccessVersion, GitHash]
    Export:
      Name: !Join ["-", ["RA", !Ref TenantName, "GitHash"]]
  AuthInstanceType:
    Value: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, AuthType]
    Export:
      Name: !Join ["-", ["RA", !Ref TenantName, "AuthInstanceType"]]
  ProxyInstanceType:
    Value: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, ProxyType]
    Export:
      Name: !Join ["-", ["RA", !Ref TenantName, "ProxyInstanceType"]]
  MaxConnections:
    Value: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, MaxConns]
    Export:
      Name: !Join ["-", ["RA", !Ref TenantName, "MaxConnections"]]
  MaxUsers:
    Value: !FindInMap [DeploymentTypeConfig, !Ref DeploymentType, MaxUsers]
    Export:
      Name: !Join ["-", ["RA", !Ref TenantName, "MaxUsers"]]
